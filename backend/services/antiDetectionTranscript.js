/**
 * Anti-Detection Transcript Extractor
 * Advanced strategies to bypass YouTube bot detection
 */

import youtubedl from 'youtube-dl-exec';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import {fileURLToPath} from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class AntiDetectionTranscriptExtractor {
 constructor() {
  // Use environment variable or default path
  this.cookiePath = process.env.YTDLP_COOKIES_PATH || path.join(__dirname, '../cookies/cookies.txt');
  this.sessionsPath = path.join(__dirname, '../cookies/sessions.json');
  this.userAgents = [
   // Real browser user agents - frequently updated
   'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
   'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
   'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
   'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/119.0',
   'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/119.0',
   // Mobile user agents (less likely to be blocked)
   'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1',
   'Mozilla/5.0 (Linux; Android 13; SM-G991B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Mobile Safari/537.36',
   'Mozilla/5.0 (iPad; CPU OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1',
  ];

  this.requestCount = 0;
  this.lastRequestTime = 0;
  this.currentSessionIndex = 0;

  this.setupEnvironment();
 }

 setupEnvironment() {
  // Create directories if they don't exist
  const cookiesDir = path.dirname(this.cookiePath);
  if (!fs.existsSync(cookiesDir)) {
   fs.mkdirSync(cookiesDir, {recursive: true});
  }

  // Initialize cookies and sessions
  this.initializeCookies();
  this.initializeSessions();

  console.log('[ANTI-DETECTION] Environment setup complete');
 }

 initializeCookies() {
  // Always regenerate cookies to ensure proper Netscape format
  console.log('[ANTI-DETECTION] Force regenerating cookies for proper Netscape format');
  this.generateRealisticCookies();
 }

 initializeSessions() {
  if (!fs.existsSync(this.sessionsPath)) {
   const sessions = this.generateBrowserSessions();
   fs.writeFileSync(this.sessionsPath, JSON.stringify(sessions, null, 2));
  }
 }

 generateRealisticCookies() {
  const now = Math.floor(Date.now() / 1000);
  const futureExpiry = now + 365 * 24 * 60 * 60; // 1 year
  const sessionExpiry = now + 2 * 60 * 60; // 2 hours for session cookies

  // Generate realistic cookie values
  const visitorId = this.generateVisitorId();
  const sessionToken = this.generateSessionToken();
  const prefValue = this.generatePreferences();

  const cookies = [
   '# Netscape HTTP Cookie File',
   '# This file contains the session cookies generated by YouTube Anti-Detection System',
   '# Generated on ' + new Date().toISOString(),
   '',
   // Essential YouTube cookies in proper Netscape format
   `.youtube.com\tTRUE\t/\tTRUE\t${futureExpiry}\tVISITOR_INFO1_LIVE\t${visitorId}`,
   `.youtube.com\tTRUE\t/\tFALSE\t${futureExpiry}\tYSC\t${sessionToken}`,
   `.youtube.com\tTRUE\t/\tTRUE\t${futureExpiry}\tPREF\t${prefValue}`,
   `youtube.com\tFALSE\t/\tFALSE\t${sessionExpiry}\tGPS\t1`,

   // Additional realistic cookies in Netscape format
   `.youtube.com\tTRUE\t/\tTRUE\t${futureExpiry}\t__Secure-3PSID\t${this.generateSecureId()}`,
   `.youtube.com\tTRUE\t/\tTRUE\t${futureExpiry}\t__Secure-3PAPISID\t${this.generateSecureId()}`,
   `.youtube.com\tTRUE\t/\tTRUE\t${futureExpiry}\tSAPISSID\t${this.generateSecureId()}`,

   // Google authentication cookies in Netscape format
   `.google.com\tTRUE\t/\tTRUE\t${futureExpiry}\tNID\t${this.generateNID()}`,
   `.google.com\tTRUE\t/\tTRUE\t${futureExpiry}\t1P_JAR\t${this.generate1PJAR()}`,

   // Timezone and location in Netscape format
   `youtube.com\tFALSE\t/\tFALSE\t${sessionExpiry}\tCONSENT\tPENDING+999`,
   `.youtube.com\tTRUE\t/\tTRUE\t${futureExpiry}\twide\t1`,

   // Additional tracking prevention in Netscape format
   `.youtube.com\tTRUE\t/\tTRUE\t${futureExpiry}\tSIDCC\t${this.generateSIDCC()}`,
   '', // Final newline
  ].join('\n');

  fs.writeFileSync(this.cookiePath, cookies);
  console.log(`[ANTI-DETECTION] Generated Netscape format cookies: ${this.cookiePath}`);
 }

 generateBrowserSessions() {
  const sessions = [];

  for (let i = 0; i < 5; i++) {
   sessions.push({
    id: i,
    userAgent: this.userAgents[i % this.userAgents.length],
    acceptLanguage: this.generateAcceptLanguage(),
    viewport: this.generateViewport(),
    timezone: this.generateTimezone(),
    fingerprint: this.generateFingerprint(),
    lastUsed: 0,
    requestCount: 0,
    success: 0,
    failures: 0,
   });
  }

  return sessions;
 }

 async extractTranscript(videoId, options = {}) {
  console.log(`[ANTI-DETECTION] Starting extraction for ${videoId}`);

  // Implement rate limiting to avoid detection
  await this.respectRateLimit();

  // Load sessions
  const sessions = this.loadSessions();
  const session = this.selectBestSession(sessions);

  console.log(`[ANTI-DETECTION] Using session ${session.id} (Success: ${session.success}, Failures: ${session.failures})`);

  // Try multiple strategies with the selected session
  const strategies = [
   () => this.extractWithCookiesAndSession(videoId, session, options),
   () => this.extractWithMobileSession(videoId, session, options),
   () => this.extractWithEmbeddedClient(videoId, session, options),
   () => this.extractWithTvClient(videoId, session, options),
   () => this.extractWithAndroidClient(videoId, session, options),
  ];

  let lastError = null;

  for (let i = 0; i < strategies.length; i++) {
   const strategyName = ['Cookies+Session', 'Mobile Session', 'Embedded Client', 'TV Client', 'Android Client'][i];

   try {
    console.log(`[ANTI-DETECTION] Trying strategy ${i + 1}/${strategies.length}: ${strategyName}`);

    const result = await this.executeWithTimeout(strategies[i](), 30000);

    if (result && result.length > 10) {
     // Update session success stats
     session.success++;
     session.lastUsed = Date.now();
     this.updateSession(session);

     console.log(`[ANTI-DETECTION] ✅ Success with ${strategyName} (${result.length} chars)`);
     return result;
    } else {
     console.log(`[ANTI-DETECTION] ❌ ${strategyName} returned empty result`);
    }
   } catch (error) {
    lastError = error;
    session.failures++;
    console.log(`[ANTI-DETECTION] ❌ ${strategyName} failed: ${error.message}`);

    // Progressive delay between strategies
    const delay = Math.min(Math.pow(2, i) * 2000, 15000);
    console.log(`[ANTI-DETECTION] Waiting ${delay}ms before next strategy...`);
    await this.delay(delay);
   }
  }

  // All strategies failed - update session and throw error
  this.updateSession(session);
  throw new Error(`All anti-detection strategies failed. Last error: ${lastError?.message || 'Unknown error'}`);
 }

 async extractWithCookiesAndSession(videoId, session, options) {
  const ytdlOptions = {
   // PART 1: IMPROVED TRANSCRIPT SOURCE QUALITY
   // Prioritize manual subtitles over auto-generated ones
   writeSubs: true, // Download manual subtitles first
   writeAutoSubs: true, // Fallback to auto-generated if manual not available
   subLang: ['id', 'en'], // Indonesian first, then English (removed 'auto' for better quality)
   subFormat: 'srv3/ttml/vtt', // High-quality subtitle formats
   skipDownload: true,
   cookies: this.cookiePath,
   userAgent: session.userAgent,

   // Realistic headers to mimic browser behavior
   addHeader: [
    `Accept-Language: ${session.acceptLanguage}`,
    'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
    'Accept-Encoding: gzip, deflate, br',
    'Cache-Control: max-age=0',
    'Sec-Fetch-Dest: document',
    'Sec-Fetch-Mode: navigate',
    'Sec-Fetch-Site: none',
    'Sec-Fetch-User: ?1',
    'Upgrade-Insecure-Requests: 1',
    'sec-ch-ua: "Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
    'sec-ch-ua-mobile: ?0',
    'sec-ch-ua-platform: "Windows"',
    'DNT: 1',
   ],

   // Use web client to avoid mobile detection
   extractorArgs: 'youtube:player_client=web',

   // Add some randomness to request timing
   sleepInterval: Math.floor(Math.random() * 2) + 1,
   limitRate: '2M',

   // Additional anti-detection measures
   geoBypassCountry: 'ID', // Set to Indonesia
   ageLimit: 999,

   // Retry settings
   retries: 2,

   // Format preference (subtitle formats)
   writeInfoJson: false,
   writeAnnotations: false,
   writeDescription: false,
   writeThumbnail: false,
  };

  console.log(`[COOKIES+SESSION] Using UA: ${session.userAgent.substring(0, 50)}...`);
  return await this.executeYtDlp(videoId, ytdlOptions, session);
 }

 async extractWithMobileSession(videoId, session, options) {
  // Force mobile user agent
  const mobileUA = 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1';

  const ytdlOptions = {
   // PART 1: IMPROVED TRANSCRIPT SOURCE QUALITY
   writeSubs: true, // Prioritize manual subtitles
   writeAutoSubs: true, // Fallback to auto-generated
   subLang: ['id', 'en'], // Indonesian first, then English
   subFormat: 'srv3/ttml/vtt', // High-quality subtitle formats
   skipDownload: true,
   userAgent: mobileUA,

   addHeader: ['Accept-Language: id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7', 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'],

   // Use iOS client
   extractorArgs: 'youtube:player_client=ios',
   geoBypassCountry: 'ID',
  };

  console.log(`[MOBILE] Using iOS mobile client`);
  return await this.executeYtDlp(videoId, ytdlOptions, session);
 }

 async extractWithEmbeddedClient(videoId, session, options) {
  const ytdlOptions = {
   // PART 1: IMPROVED TRANSCRIPT SOURCE QUALITY
   writeSubs: true, // Prioritize manual subtitles
   writeAutoSubs: true, // Fallback to auto-generated
   subLang: ['id', 'en'], // Indonesian first, then English
   subFormat: 'srv3/ttml/vtt', // High-quality subtitle formats
   skipDownload: true,
   cookies: this.cookiePath,
   userAgent: session.userAgent,

   // Use embedded client (often less restricted)
   extractorArgs: 'youtube:player_client=web_embedded',

   addHeader: [
    `Accept-Language: ${session.acceptLanguage}`,
    'X-YouTube-Client-Name: 2', // WEB_EMBEDDED client
    'X-YouTube-Client-Version: 1.0',
   ],
  };

  console.log(`[EMBEDDED] Using web embedded client`);
  return await this.executeYtDlp(videoId, ytdlOptions, session);
 }

 async extractWithTvClient(videoId, session, options) {
  const ytdlOptions = {
   // PART 1: IMPROVED TRANSCRIPT SOURCE QUALITY
   writeSubs: true, // Prioritize manual subtitles
   writeAutoSubs: true, // Fallback to auto-generated
   subLang: ['id', 'en'], // Indonesian first, then English
   subFormat: 'srv3/ttml/vtt', // High-quality subtitle formats
   skipDownload: true,
   userAgent: 'Mozilla/5.0 (SMART-TV; Linux; Tizen 6.0) AppleWebKit/538.1 (KHTML, like Gecko) Version/6.0 TV Safari/538.1',

   // Use TV client (different detection patterns)
   extractorArgs: 'youtube:player_client=tv_embedded',

   addHeader: [
    'Accept-Language: id-ID,id;q=0.9',
    'X-YouTube-Client-Name: 85', // TVHTML5_SIMPLY_EMBEDDED_PLAYER
    'X-YouTube-Client-Version: 2.0',
   ],
  };

  console.log(`[TV] Using TV embedded client`);
  return await this.executeYtDlp(videoId, ytdlOptions, session);
 }

 async extractWithAndroidClient(videoId, session, options) {
  const ytdlOptions = {
   // PART 1: IMPROVED TRANSCRIPT SOURCE QUALITY
   writeSubs: true, // Prioritize manual subtitles
   writeAutoSubs: true, // Fallback to auto-generated
   subLang: ['id', 'en'], // Indonesian first, then English
   subFormat: 'srv3/ttml/vtt', // High-quality subtitle formats
   skipDownload: true,
   userAgent: 'com.google.android.youtube/17.36.4 (Linux; U; Android 11; SM-G973F Build/RP1A.200720.012) gzip',

   // Use Android client
   extractorArgs: 'youtube:player_client=android',

   addHeader: [
    'Accept-Language: id-ID, id, en-US, en',
    'X-YouTube-Client-Name: 3', // ANDROID client
    'X-YouTube-Client-Version: 17.36.4',
   ],
  };

  console.log(`[ANDROID] Using Android client`);
  return await this.executeYtDlp(videoId, ytdlOptions, session);
 }

 async executeYtDlp(videoId, options, session) {
  const tempDir = path.join(__dirname, '../temp');
  if (!fs.existsSync(tempDir)) {
   fs.mkdirSync(tempDir, {recursive: true});
  }

  const timestamp = Date.now();
  const outputTemplate = path.join(tempDir, `${videoId}-${timestamp}-%(title)s.%(ext)s`);
  options.output = outputTemplate;

  session.requestCount++;

  try {
   console.log(`[YT-DLP] Executing extraction for ${videoId}`);
   console.log(`[YT-DLP] Output template: ${outputTemplate}`);

   // Execute yt-dlp
   await youtubedl(`https://www.youtube.com/watch?v=${videoId}`, options);

   // Look for generated subtitle files
   const files = fs.readdirSync(tempDir);
   const subtitleFiles = files.filter((file) => file.includes(videoId) && file.includes(timestamp.toString()) && (file.endsWith('.vtt') || file.endsWith('.srt')));

   console.log(`[YT-DLP] Found ${subtitleFiles.length} subtitle files`);

   if (subtitleFiles.length > 0) {
    // Prefer Indonesian, then English, then any language
    const preferredFile = this.selectBestSubtitleFile(subtitleFiles);
    const subtitlePath = path.join(tempDir, preferredFile);

    console.log(`[YT-DLP] Reading subtitle file: ${preferredFile}`);

    const subtitleContent = fs.readFileSync(subtitlePath, 'utf8');
    const transcript = this.parseSubtitleContent(subtitleContent);

    // Cleanup temporary files
    this.cleanupTempFiles(tempDir, videoId, timestamp);

    if (transcript && transcript.length > 10) {
     console.log(`[YT-DLP] ✅ Successfully extracted transcript (${transcript.length} chars)`);
     return transcript;
    } else {
     throw new Error('Extracted transcript is too short or empty');
    }
   } else {
    throw new Error('No subtitle files generated by yt-dlp');
   }
  } catch (error) {
   // Cleanup on error
   this.cleanupTempFiles(tempDir, videoId, timestamp);

   console.error(`[YT-DLP] ❌ Error: ${error.message}`);
   throw new Error(`yt-dlp extraction failed: ${error.message}`);
  }
 }

 selectBestSubtitleFile(files) {
  // PART 1: IMPROVED SUBTITLE SELECTION - Prioritize manual over auto-generated
  // Preference order: Manual Indonesian > Manual English > Auto Indonesian > Auto English > Others

  console.log(`[SUBTITLE-SELECTOR] Selecting best from ${files.length} subtitle files:`, files);

  // First, try to find manual subtitles (non-auto)
  const manualSubtitles = files.filter((file) => !file.includes('.auto.') && !file.includes('-auto.'));
  const autoSubtitles = files.filter((file) => file.includes('.auto.') || file.includes('-auto.'));

  console.log(`[SUBTITLE-SELECTOR] Found ${manualSubtitles.length} manual and ${autoSubtitles.length} auto-generated files`);

  // Priority 1: Manual Indonesian subtitles
  const manualId = manualSubtitles.find((file) => file.includes('.id.') || file.includes('-id.'));
  if (manualId) {
   console.log(`[SUBTITLE-SELECTOR] ✅ Selected manual Indonesian: ${manualId}`);
   return manualId;
  }

  // Priority 2: Manual English subtitles
  const manualEn = manualSubtitles.find((file) => file.includes('.en.') || file.includes('-en.'));
  if (manualEn) {
   console.log(`[SUBTITLE-SELECTOR] ✅ Selected manual English: ${manualEn}`);
   return manualEn;
  }

  // Priority 3: Any other manual subtitles
  if (manualSubtitles.length > 0) {
   console.log(`[SUBTITLE-SELECTOR] ✅ Selected manual (other language): ${manualSubtitles[0]}`);
   return manualSubtitles[0];
  }

  // Priority 4: Auto-generated Indonesian
  const autoId = autoSubtitles.find((file) => file.includes('.id.') || file.includes('-id.'));
  if (autoId) {
   console.log(`[SUBTITLE-SELECTOR] ⚠️ Selected auto-generated Indonesian: ${autoId}`);
   return autoId;
  }

  // Priority 5: Auto-generated English
  const autoEn = autoSubtitles.find((file) => file.includes('.en.') || file.includes('-en.'));
  if (autoEn) {
   console.log(`[SUBTITLE-SELECTOR] ⚠️ Selected auto-generated English: ${autoEn}`);
   return autoEn;
  }

  // Priority 6: Any remaining file
  console.log(`[SUBTITLE-SELECTOR] ⚠️ Selected fallback: ${files[0]}`);
  return files[0];
 }

 parseSubtitleContent(content) {
  try {
   const lines = content.split('\n');
   const textLines = [];

   for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines, timestamps, and metadata
    if (!trimmed || trimmed.includes('-->') || /^\d+$/.test(trimmed) || trimmed.startsWith('WEBVTT') || trimmed.startsWith('NOTE') || trimmed.startsWith('STYLE') || trimmed.startsWith('::cue')) {
     continue;
    }

    // Enhanced cleaning with more precise patterns
    let cleaned = trimmed
     // Clean HTML tags but preserve content structure
     .replace(/<\/?[^>]+(>|$)/g, '')
     // HTML entities
     .replace(/&lt;/g, '<')
     .replace(/&gt;/g, '>')
     .replace(/&amp;/g, '&')
     .replace(/&quot;/g, '"')
     .replace(/&#39;/g, "'")
     .replace(/&nbsp;/g, ' ')
     // Only remove common non-speech annotations, preserve actual content
     .replace(/\[Music\]/gi, '')
     .replace(/\[Applause\]/gi, '')
     .replace(/\[Laughter\]/gi, '')
     .replace(/\[Silence\]/gi, '')
     .replace(/\[Inaudible\]/gi, '')
     // Remove speaker identification patterns like "(Speaker 1):" but keep content in parentheses
     .replace(/^\([^)]*\):/g, '')
     // Clean multiple whitespace
     .replace(/\s+/g, ' ')
     .trim();

    // Keep content if it's substantial and appears to be actual speech
    if (cleaned && cleaned.length > 2 && !cleaned.match(/^[\[\(].*[\]\)]$/)) {
     textLines.push(cleaned);
    }
   }

   const transcript = textLines.join(' ').replace(/\s+/g, ' ').trim();

   console.log(`[PARSER] Enhanced processing: ${textLines.length} text lines -> ${transcript.length} chars`);

   return transcript;
  } catch (error) {
   console.error('[PARSER] Error parsing subtitle content:', error);
   return null;
  }
 }

 // Enhanced method: Parse subtitle content with timing information
 parseSubtitleSegments(content) {
  try {
   const lines = content.split('\n');
   const segments = [];
   let currentSegment = null;

   for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // Skip empty lines and metadata
    if (!line || line.startsWith('WEBVTT') || line.startsWith('NOTE') || line.startsWith('STYLE') || line.startsWith('::cue')) {
     continue;
    }

    // Enhanced timing pattern matching (WebVTT format: 00:00:10.500 --> 00:00:13.250)
    const timeMatch = line.match(/^(\d{2}:\d{2}:\d{2}\.\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}\.\d{3})/);
    if (timeMatch) {
     const startTime = this.parseTimeToSeconds(timeMatch[1]);
     const endTime = this.parseTimeToSeconds(timeMatch[2]);

     // Look ahead for the text content
     let textContent = '';
     let j = i + 1;
     while (j < lines.length && lines[j].trim() && !lines[j].includes('-->')) {
      const textLine = lines[j].trim();
      if (textLine) {
       // Enhanced text cleaning
       const cleaned = textLine
        .replace(/<\/?[^>]+(>|$)/g, '') // Remove HTML tags
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&nbsp;/g, ' ')
        // Only remove common annotations
        .replace(/\[Music\]/gi, '')
        .replace(/\[Applause\]/gi, '')
        .replace(/\[Laughter\]/gi, '')
        .replace(/\[Silence\]/gi, '')
        .replace(/\[Inaudible\]/gi, '')
        // Remove speaker tags but keep content
        .replace(/^\([^)]*\):/g, '')
        .replace(/\s+/g, ' ')
        .trim();

       if (cleaned && cleaned.length > 1 && !cleaned.match(/^[\[\(].*[\]\)]$/)) {
        textContent += (textContent ? ' ' : '') + cleaned;
       }
      }
      j++;
     }

     // Only add segment if it has substantial content and reasonable duration
     if (textContent && textContent.length > 5 && endTime - startTime >= 0.5) {
      segments.push({
       start: startTime,
       end: endTime,
       text: textContent,
       duration: endTime - startTime,
      });
     }

     i = j - 1; // Skip ahead to where we stopped reading text
    }
   }

   // Merge very short adjacent segments to create more meaningful chunks
   const mergedSegments = this.mergeShortSegments(segments);

   console.log(`[PARSER] Enhanced segments extraction: ${segments.length} raw -> ${mergedSegments.length} merged segments`);
   return mergedSegments;
  } catch (error) {
   console.error('[PARSER] Error parsing subtitle segments:', error);
   return [];
  }
 }

 // Helper method: Convert time string to seconds
 parseTimeToSeconds(timeString) {
  const [time, milliseconds] = timeString.split('.');
  const [hours, minutes, seconds] = time.split(':').map(Number);
  return hours * 3600 + minutes * 60 + seconds + parseInt(milliseconds) / 1000;
 }

 // Helper method: Merge short segments for better content flow
 mergeShortSegments(segments) {
  if (segments.length === 0) return segments;

  const merged = [];
  let currentSegment = segments[0];

  for (let i = 1; i < segments.length; i++) {
   const nextSegment = segments[i];

   // Merge if current segment is very short (< 2 seconds) and gap is small (< 1 second)
   if (currentSegment.duration < 2.0 && nextSegment.start - currentSegment.end < 1.0 && (currentSegment.text + ' ' + nextSegment.text).length < 200) {
    // Merge segments
    currentSegment = {
     start: currentSegment.start,
     end: nextSegment.end,
     text: currentSegment.text + ' ' + nextSegment.text,
     duration: nextSegment.end - currentSegment.start,
    };
   } else {
    merged.push(currentSegment);
    currentSegment = nextSegment;
   }
  }

  // Don't forget the last segment
  merged.push(currentSegment);

  return merged;
 }

 // NEW METHOD: Extract transcript with timing segments
 async extractTranscriptWithSegments(videoId, options = {}) {
  console.log(`[ANTI-DETECTION] Starting segments extraction for ${videoId}`);

  // Implement rate limiting to avoid detection
  await this.respectRateLimit();

  // Load sessions
  const sessions = this.loadSessions();
  const session = this.selectBestSession(sessions);

  console.log(`[ANTI-DETECTION] Using session ${session.id} for segments (Success: ${session.success}, Failures: ${session.failures})`);

  // Try to extract subtitle files with timing
  const strategies = [
   () => this.extractSegmentsWithCookiesAndSession(videoId, session, options),
   () => this.extractSegmentsWithMobileSession(videoId, session, options),
   () => this.extractSegmentsWithEmbeddedClient(videoId, session, options),
  ];

  let lastError = null;

  for (let i = 0; i < strategies.length; i++) {
   const strategyName = ['Cookies+Session (Segments)', 'Mobile Session (Segments)', 'Embedded Client (Segments)'][i];

   try {
    console.log(`[ANTI-DETECTION] Trying segments strategy ${i + 1}/${strategies.length}: ${strategyName}`);

    const result = await this.executeWithTimeout(strategies[i](), 45000); // Longer timeout for file processing

    if (result && result.length > 0) {
     // Update session success stats
     session.success++;
     session.lastUsed = Date.now();
     this.updateSession(session);

     console.log(`[ANTI-DETECTION] ✅ Success with ${strategyName} (${result.length} segments)`);
     return result;
    } else {
     console.log(`[ANTI-DETECTION] ❌ ${strategyName} returned no segments`);
    }
   } catch (error) {
    lastError = error;
    session.failures++;
    console.log(`[ANTI-DETECTION] ❌ ${strategyName} failed: ${error.message}`);

    // Progressive delay between strategies
    const delay = Math.min(Math.pow(2, i) * 3000, 20000);
    console.log(`[ANTI-DETECTION] Waiting ${delay}ms before next strategy...`);
    await this.delay(delay);
   }
  }

  // All strategies failed - update session and throw error
  this.updateSession(session);
  throw new Error(`All anti-detection segment strategies failed. Last error: ${lastError?.message || 'Unknown error'}`);
 }

 async extractSegmentsWithCookiesAndSession(videoId, session, options) {
  return this.extractSegmentsWithStrategy(videoId, session, options, 'cookies');
 }

 async extractSegmentsWithMobileSession(videoId, session, options) {
  return this.extractSegmentsWithStrategy(videoId, session, options, 'mobile');
 }

 async extractSegmentsWithEmbeddedClient(videoId, session, options) {
  return this.extractSegmentsWithStrategy(videoId, session, options, 'embedded');
 }

 async extractSegmentsWithStrategy(videoId, session, options, strategy) {
  const tempDir = path.join(__dirname, '../temp');
  if (!fs.existsSync(tempDir)) {
   fs.mkdirSync(tempDir, {recursive: true});
  }

  const timestamp = Date.now();

  let ytdlOptions = {
   // PART 1: IMPROVED TRANSCRIPT SOURCE QUALITY WITH TIMING
   writeSubs: true, // Prioritize manual subtitles
   writeAutoSubs: true, // Fallback to auto-generated
   subLang: ['id', 'en'], // Indonesian first, then English (removed 'auto' for better quality)
   subFormat: 'srv3/ttml/vtt', // High-quality subtitle formats with timing
   skipDownload: true,
   userAgent: session.userAgent,
   addHeader: [
    `Accept-Language: ${session.acceptLanguage}`,
    `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`,
    `Accept-Encoding: gzip, deflate, br`,
    `Cache-Control: no-cache`,
    `Pragma: no-cache`,
    `DNT: 1`,
    `Sec-Fetch-Dest: document`,
    `Sec-Fetch-Mode: navigate`,
    `Sec-Fetch-Site: none`,
    `Upgrade-Insecure-Requests: 1`,
   ],
   output: path.join(tempDir, `${videoId}-${timestamp}.%(ext)s`),
   writeSubVtt: true, // Ensure VTT format
  };

  if (strategy === 'cookies') {
   ytdlOptions.cookies = this.cookiePath;
  }

  if (strategy === 'mobile') {
   ytdlOptions.userAgent = 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15';
   ytdlOptions.format = 'worst'; // Mobile typically requests lower quality
  }

  const url = `https://www.youtube.com/watch?v=${videoId}`;

  try {
   console.log(`[YT-DLP-SEGMENTS] Executing yt-dlp for segments with ${strategy} strategy...`);

   // Execute yt-dlp to get subtitle files
   const {stdout, stderr} = await youtubedl(url, ytdlOptions);

   console.log(`[YT-DLP-SEGMENTS] Execution complete, looking for subtitle files...`);

   // Look for generated subtitle files
   const files = fs.readdirSync(tempDir);
   const subtitleFiles = files.filter((file) => file.includes(videoId) && file.includes(timestamp.toString()) && (file.endsWith('.vtt') || file.endsWith('.srt')));

   console.log(`[YT-DLP-SEGMENTS] Found ${subtitleFiles.length} subtitle files`);

   if (subtitleFiles.length > 0) {
    // Select the best subtitle file (prefer Indonesian, then English, then auto-generated)
    const preferredFile = this.selectBestSubtitleFile(subtitleFiles);
    const subtitlePath = path.join(tempDir, preferredFile);

    console.log(`[YT-DLP-SEGMENTS] Reading subtitle file: ${preferredFile}`);

    const subtitleContent = fs.readFileSync(subtitlePath, 'utf8');
    const segments = this.parseSubtitleSegments(subtitleContent);

    // Cleanup temp files
    this.cleanupTempFiles(tempDir, videoId, timestamp);

    if (segments && segments.length > 0) {
     return segments;
    } else {
     throw new Error('No valid segments found in subtitle file');
    }
   } else {
    throw new Error('No subtitle files generated by yt-dlp');
   }
  } catch (error) {
   // Cleanup temp files on error
   this.cleanupTempFiles(tempDir, videoId, timestamp);
   throw error;
  }
 }

 cleanupTempFiles(tempDir, videoId, timestamp) {
  try {
   const files = fs.readdirSync(tempDir);
   const relatedFiles = files.filter((file) => file.includes(videoId) && file.includes(timestamp.toString()));

   for (const file of relatedFiles) {
    const filePath = path.join(tempDir, file);
    fs.unlinkSync(filePath);
   }

   console.log(`[CLEANUP] Removed ${relatedFiles.length} temporary files`);
  } catch (error) {
   console.log(`[CLEANUP] Warning: Could not cleanup temp files: ${error.message}`);
  }
 }

 // Session management methods
 loadSessions() {
  try {
   if (fs.existsSync(this.sessionsPath)) {
    return JSON.parse(fs.readFileSync(this.sessionsPath, 'utf8'));
   }
  } catch (error) {
   console.log('[SESSIONS] Error loading sessions, regenerating...');
  }

  const sessions = this.generateBrowserSessions();
  fs.writeFileSync(this.sessionsPath, JSON.stringify(sessions, null, 2));
  return sessions;
 }

 selectBestSession(sessions) {
  // Select session with best success rate and least recent usage
  return sessions.sort((a, b) => {
   const aScore = a.success / Math.max(a.success + a.failures, 1) - (Date.now() - a.lastUsed) / 1000000;
   const bScore = b.success / Math.max(b.success + b.failures, 1) - (Date.now() - b.lastUsed) / 1000000;
   return bScore - aScore;
  })[0];
 }

 updateSession(session) {
  const sessions = this.loadSessions();
  const index = sessions.findIndex((s) => s.id === session.id);
  if (index >= 0) {
   sessions[index] = session;
   fs.writeFileSync(this.sessionsPath, JSON.stringify(sessions, null, 2));
  }
 }

 async respectRateLimit() {
  const now = Date.now();
  const timeSinceLastRequest = now - this.lastRequestTime;
  const minInterval = 3000; // Minimum 3 seconds between requests

  if (timeSinceLastRequest < minInterval) {
   const delay = minInterval - timeSinceLastRequest;
   console.log(`[RATE-LIMIT] Waiting ${delay}ms...`);
   await this.delay(delay);
  }

  this.lastRequestTime = Date.now();
  this.requestCount++;
 }

 async executeWithTimeout(promise, timeout) {
  return Promise.race([promise, new Promise((_, reject) => setTimeout(() => reject(new Error('Operation timeout')), timeout))]);
 }

 delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
 }

 // Cookie generation helpers
 generateVisitorId() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
  let result = '';
  for (let i = 0; i < 22; i++) {
   result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
 }

 generateSessionToken() {
  return crypto.randomBytes(8).toString('hex');
 }

 generatePreferences() {
  const prefs = ['tz=Asia.Jakarta', 'f1=50000000', 'f6=40000000', 'hl=id'];
  return prefs.join('&');
 }

 generateSecureId() {
  return crypto.randomBytes(16).toString('hex');
 }

 generateNID() {
  const timestamp = Math.floor(Date.now() / 1000);
  return `511=${crypto.randomBytes(32).toString('hex')}-${timestamp}`;
 }

 generate1PJAR() {
  const date = new Date();
  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}-${String(date.getHours()).padStart(2, '0')}`;
 }

 generateSIDCC() {
  return crypto.randomBytes(24).toString('hex');
 }

 generateAcceptLanguage() {
  return 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7';
 }

 generateViewport() {
  const viewports = ['1920x1080', '1366x768', '1440x900', '1024x768'];
  return viewports[Math.floor(Math.random() * viewports.length)];
 }

 generateTimezone() {
  return 'Asia/Jakarta';
 }

 generateFingerprint() {
  return crypto.randomBytes(16).toString('hex');
 }

 // Debug methods
 getStats() {
  const sessions = this.loadSessions();
  return {
   totalRequests: this.requestCount,
   sessions: sessions.map((s) => ({
    id: s.id,
    userAgent: s.userAgent.substring(0, 50) + '...',
    success: s.success,
    failures: s.failures,
    successRate: s.success / Math.max(s.success + s.failures, 1),
    lastUsed: s.lastUsed ? new Date(s.lastUsed).toISOString() : 'never',
   })),
  };
 }

 clearCache() {
  // Clear cookies and sessions to force regeneration
  if (fs.existsSync(this.cookiePath)) {
   fs.unlinkSync(this.cookiePath);
  }
  if (fs.existsSync(this.sessionsPath)) {
   fs.unlinkSync(this.sessionsPath);
  }
  console.log('[ANTI-DETECTION] Cache cleared');
 }
}

export default new AntiDetectionTranscriptExtractor();
