/**
 * Advanced Transcript Extractor - Comprehensive Solution
 *
 * This service implements multiple advanced strategies for transcript extraction:
 * 1. Enhanced yt-dlp with VTT/JSON parsing
 * 2. Alternative API endpoints
 * 3. Subtitle file detection and parsing
 * 4. Multi-format support (VTT, SRT, JSON3, TTML)
 */

const fs = require('fs');
const path = require('path');
const {execSync, spawn} = require('child_process');
const glob = require('glob');

class AdvancedTranscriptExtractor {
 constructor(options = {}) {
  this.tempDir = options.tempDir || path.join(process.cwd(), 'temp');
  this.cleanupEnabled = options.cleanup !== false;
  this.maxRetries = options.maxRetries || 3;

  // Ensure temp directory exists
  this.ensureTempDir();
 }

 ensureTempDir() {
  if (!fs.existsSync(this.tempDir)) {
   fs.mkdirSync(this.tempDir, {recursive: true});
   console.log(`[ADV-TRANSCRIPT] 📁 Created temp directory: ${this.tempDir}`);
  }
 }

 /**
  * Main extraction method with comprehensive fallback strategies
  */
 async extractTranscript(videoId, options = {}) {
  console.log(`[ADV-TRANSCRIPT] 🚀 Starting advanced extraction for ${videoId}`);

  const strategies = [
   {name: 'auto-generated-vtt', method: this.extractAutoGeneratedVTT.bind(this)},
   {name: 'manual-subtitles-vtt', method: this.extractManualSubtitlesVTT.bind(this)},
   {name: 'json3-format', method: this.extractJSON3Format.bind(this)},
   {name: 'multi-language-fallback', method: this.extractMultiLanguage.bind(this)},
   {name: 'alternative-endpoints', method: this.extractFromAlternativeEndpoints.bind(this)},
  ];

  let lastError = null;

  for (const strategy of strategies) {
   try {
    console.log(`[ADV-TRANSCRIPT] 🎯 Trying strategy: ${strategy.name}`);

    const result = await strategy.method(videoId, options);

    if (result && result.segments && result.segments.length > 0) {
     console.log(`[ADV-TRANSCRIPT] ✅ Success with ${strategy.name}: ${result.segments.length} segments`);

     // Cleanup temp files if enabled
     if (this.cleanupEnabled) {
      await this.cleanupTempFiles(videoId);
     }

     return {
      ...result,
      extractionStrategy: strategy.name,
      totalSegments: result.segments.length,
      totalDuration: this.calculateTotalDuration(result.segments),
     };
    }
   } catch (error) {
    console.log(`[ADV-TRANSCRIPT] ❌ Strategy ${strategy.name} failed: ${error.message}`);
    lastError = error;
   }
  }

  throw new Error(`All extraction strategies failed. Last error: ${lastError?.message || 'Unknown error'}`);
 }

 /**
  * Strategy 1: Extract auto-generated VTT subtitles
  */
 async extractAutoGeneratedVTT(videoId, options = {}) {
  console.log(`[ADV-TRANSCRIPT] 📝 Extracting auto-generated VTT for ${videoId}`);

  const {executeYtDlpSecurelyCore} = require('../server.js');
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  // 🇮🇩 INDONESIAN-FIRST PRIORITY: Try Indonesian first, then English
  const args = ['--write-auto-sub', '--sub-format', 'vtt', '--sub-lang', 'id,en', '--skip-download', '--output', path.join(this.tempDir, `${videoId}.%(ext)s`), videoUrl];

  try {
   await executeYtDlpSecurelyCore(args, {
    useCookies: true,
    timeout: 30000,
    ...options,
   });

   // Find and parse VTT files
   const vttFiles = await this.findSubtitleFiles(videoId, ['vtt']);

   for (const file of vttFiles) {
    const segments = await this.parseVTTFile(file);
    if (segments && segments.length > 0) {
     return {
      segments,
      source: 'yt-dlp-auto-vtt',
      language: 'en',
      format: 'vtt',
     };
    }
   }

   throw new Error('No valid VTT content found');
  } catch (error) {
   throw new Error(`Auto-generated VTT extraction failed: ${error.message}`);
  }
 }

 /**
  * Strategy 2: Extract manual subtitles in VTT format
  */
 async extractManualSubtitlesVTT(videoId, options = {}) {
  console.log(`[ADV-TRANSCRIPT] 📝 Extracting manual VTT subtitles for ${videoId}`);

  const {executeYtDlpSecurelyCore} = require('../server.js');
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  // 🇮🇩 INDONESIAN-FIRST PRIORITY: Try Indonesian first, then English variants
  const args = ['--write-sub', '--sub-format', 'vtt', '--sub-lang', 'id,en,en-US,en-GB', '--skip-download', '--output', path.join(this.tempDir, `${videoId}.%(ext)s`), videoUrl];

  try {
   await executeYtDlpSecurelyCore(args, {
    useCookies: true,
    timeout: 30000,
    ...options,
   });

   const vttFiles = await this.findSubtitleFiles(videoId, ['vtt']);

   for (const file of vttFiles) {
    const segments = await this.parseVTTFile(file);
    if (segments && segments.length > 0) {
     return {
      segments,
      source: 'yt-dlp-manual-vtt',
      language: this.extractLanguageFromFilename(file),
      format: 'vtt',
     };
    }
   }

   throw new Error('No valid manual VTT content found');
  } catch (error) {
   throw new Error(`Manual VTT extraction failed: ${error.message}`);
  }
 }

 /**
  * Strategy 3: Extract JSON3 format for better parsing
  */
 async extractJSON3Format(videoId, options = {}) {
  console.log(`[ADV-TRANSCRIPT] 🔧 Extracting JSON3 format for ${videoId}`);

  const {executeYtDlpSecurelyCore} = require('../server.js');
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  // 🇮🇩 INDONESIAN-FIRST PRIORITY: Try Indonesian first, then English
  const args = ['--write-auto-sub', '--sub-format', 'json3', '--sub-lang', 'id,en', '--skip-download', '--output', path.join(this.tempDir, `${videoId}.%(ext)s`), videoUrl];

  try {
   await executeYtDlpSecurelyCore(args, {
    useCookies: true,
    timeout: 30000,
    ...options,
   });

   const jsonFiles = await this.findSubtitleFiles(videoId, ['json3', 'json']);

   for (const file of jsonFiles) {
    const segments = await this.parseJSON3File(file);
    if (segments && segments.length > 0) {
     return {
      segments,
      source: 'yt-dlp-json3',
      language: 'en',
      format: 'json3',
     };
    }
   }

   throw new Error('No valid JSON3 content found');
  } catch (error) {
   throw new Error(`JSON3 extraction failed: ${error.message}`);
  }
 }

 /**
  * Strategy 4: Multi-language fallback
  */
 async extractMultiLanguage(videoId, options = {}) {
  console.log(`[ADV-TRANSCRIPT] 🌍 Trying multi-language extraction for ${videoId}`);

  const {executeYtDlpSecurelyCore} = require('../server.js');
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  // 🇮🇩 INDONESIAN-FIRST PRIORITY: Put Indonesian first for Indonesian content
  const languages = ['id', 'en', 'en-US', 'en-GB', 'en-CA', 'en-AU'];

  for (const lang of languages) {
   try {
    console.log(`[ADV-TRANSCRIPT] 🔄 Trying language: ${lang}`);

    const args = ['--write-auto-sub', '--write-sub', '--sub-format', 'vtt', '--sub-lang', lang, '--skip-download', '--output', path.join(this.tempDir, `${videoId}_${lang}.%(ext)s`), videoUrl];

    await executeYtDlpSecurelyCore(args, {
     useCookies: true,
     timeout: 25000,
     ...options,
    });

    const vttFiles = await this.findSubtitleFiles(`${videoId}_${lang}`, ['vtt']);

    for (const file of vttFiles) {
     const segments = await this.parseVTTFile(file);
     if (segments && segments.length > 0) {
      return {
       segments,
       source: 'yt-dlp-multilang',
       language: lang,
       format: 'vtt',
      };
     }
    }
   } catch (error) {
    console.log(`[ADV-TRANSCRIPT] ❌ Language ${lang} failed: ${error.message}`);
   }
  }

  throw new Error('All language fallbacks failed');
 }

 /**
  * Strategy 5: Alternative endpoints (YouTube internal APIs)
  */
 async extractFromAlternativeEndpoints(videoId, options = {}) {
  console.log(`[ADV-TRANSCRIPT] 🔄 Trying alternative endpoints for ${videoId}`);

  try {
   // Try YouTube internal player API
   const playerResponse = await this.fetchPlayerResponse(videoId);

   if (playerResponse && playerResponse.captions) {
    const segments = await this.extractFromPlayerResponse(playerResponse);
    if (segments && segments.length > 0) {
     return {
      segments,
      source: 'youtube-internal-api',
      language: 'en',
      format: 'internal',
     };
    }
   }

   throw new Error('No captions found in player response');
  } catch (error) {
   throw new Error(`Alternative endpoints failed: ${error.message}`);
  }
 }

 /**
  * Find subtitle files matching patterns
  */
 async findSubtitleFiles(videoId, extensions = ['vtt', 'json3', 'json', 'srt']) {
  const patterns = [];

  for (const ext of extensions) {
   patterns.push(path.join(this.tempDir, `${videoId}.${ext}`), path.join(this.tempDir, `${videoId}.en.${ext}`), path.join(this.tempDir, `${videoId}.en-*.${ext}`), path.join(this.tempDir, `*${videoId}*.${ext}`));
  }

  const files = [];
  for (const pattern of patterns) {
   try {
    const matches = glob.sync(pattern);
    files.push(...matches);
   } catch (error) {
    // Continue searching
   }
  }

  // Remove duplicates and filter existing files
  const uniqueFiles = [...new Set(files)].filter((file) => {
   const exists = fs.existsSync(file);
   if (exists) {
    const stats = fs.statSync(file);
    console.log(`[ADV-TRANSCRIPT] 📄 Found subtitle file: ${file} (${stats.size} bytes)`);
   }
   return exists;
  });

  return uniqueFiles;
 }

 /**
  * Parse VTT file content
  */
 async parseVTTFile(filePath) {
  try {
   const content = fs.readFileSync(filePath, 'utf8');
   console.log(`[ADV-TRANSCRIPT] 📖 Parsing VTT file: ${filePath} (${content.length} chars)`);

   if (!content.includes('WEBVTT')) {
    throw new Error('Invalid VTT format - missing WEBVTT header');
   }

   const segments = [];
   const lines = content.split('\n');
   let currentSegment = null;

   for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // Skip empty lines and headers
    if (!line || line.includes('WEBVTT') || line.startsWith('NOTE')) {
     continue;
    }

    // Check for timestamp line (00:00:00.000 --> 00:00:05.000)
    const timestampMatch = line.match(/^(\d{2}:\d{2}:\d{2}[\.\,]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[\.\,]\d{3})/);

    if (timestampMatch) {
     // Save previous segment
     if (currentSegment && currentSegment.text.trim()) {
      segments.push(currentSegment);
     }

     // Start new segment
     const startTime = this.timeToSeconds(timestampMatch[1]);
     const endTime = this.timeToSeconds(timestampMatch[2]);

     currentSegment = {
      start: startTime,
      duration: endTime - startTime,
      text: '',
     };
    } else if (currentSegment && line && !line.match(/^\d+$/)) {
     // This is subtitle text (skip line numbers)
     currentSegment.text += (currentSegment.text ? ' ' : '') + line;
    }
   }

   // Add final segment
   if (currentSegment && currentSegment.text.trim()) {
    segments.push(currentSegment);
   }

   // Clean up text content
   const cleanedSegments = segments
    .map((seg) => ({
     ...seg,
     text: this.cleanSubtitleText(seg.text),
    }))
    .filter((seg) => seg.text.length > 0);

   console.log(`[ADV-TRANSCRIPT] ✅ Parsed ${cleanedSegments.length} segments from VTT`);
   return cleanedSegments;
  } catch (error) {
   console.log(`[ADV-TRANSCRIPT] ❌ VTT parsing failed: ${error.message}`);
   return null;
  }
 }

 /**
  * Parse JSON3 subtitle file
  */
 async parseJSON3File(filePath) {
  try {
   const content = fs.readFileSync(filePath, 'utf8');
   console.log(`[ADV-TRANSCRIPT] 📖 Parsing JSON3 file: ${filePath} (${content.length} chars)`);

   const data = JSON.parse(content);
   const segments = [];

   if (data.events) {
    for (const event of data.events) {
     if (event.segs) {
      let text = '';
      for (const seg of event.segs) {
       if (seg.utf8) {
        text += seg.utf8;
       }
      }

      if (text.trim()) {
       segments.push({
        start: (event.tStartMs || 0) / 1000,
        duration: (event.dDurationMs || 0) / 1000,
        text: this.cleanSubtitleText(text),
       });
      }
     }
    }
   }

   console.log(`[ADV-TRANSCRIPT] ✅ Parsed ${segments.length} segments from JSON3`);
   return segments.filter((seg) => seg.text.length > 0);
  } catch (error) {
   console.log(`[ADV-TRANSCRIPT] ❌ JSON3 parsing failed: ${error.message}`);
   return null;
  }
 }

 /**
  * Fetch YouTube player response
  */
 async fetchPlayerResponse(videoId) {
  const fetch = (await import('node-fetch')).default;

  try {
   const response = await fetch('https://www.youtube.com/youtubei/v1/player', {
    method: 'POST',
    headers: {
     'Content-Type': 'application/json',
     'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    },
    body: JSON.stringify({
     context: {
      client: {
       clientName: 'WEB',
       clientVersion: '2.20240101.00.00',
      },
     },
     videoId: videoId,
    }),
   });

   if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
   }

   return await response.json();
  } catch (error) {
   throw new Error(`Player response fetch failed: ${error.message}`);
  }
 }

 /**
  * Extract segments from player response
  */
 async extractFromPlayerResponse(playerResponse) {
  try {
   if (!playerResponse.captions || !playerResponse.captions.playerCaptionsTracklistRenderer) {
    throw new Error('No captions in player response');
   }

   const tracks = playerResponse.captions.playerCaptionsTracklistRenderer.captionTracks;

   if (!tracks || tracks.length === 0) {
    throw new Error('No caption tracks found');
   }

   // Find English track
   const track = tracks.find((t) => t.languageCode === 'en') || tracks[0];

   if (!track.baseUrl) {
    throw new Error('No caption URL found');
   }

   // Fetch caption content
   const fetch = (await import('node-fetch')).default;
   const response = await fetch(track.baseUrl);
   const captionData = await response.text();

   // Parse as VTT-like content
   return this.parseVTTLikeContent(captionData);
  } catch (error) {
   throw new Error(`Player response extraction failed: ${error.message}`);
  }
 }

 /**
  * Parse VTT-like content from various sources
  */
 parseVTTLikeContent(content) {
  const segments = [];

  // Handle different caption formats
  if (content.includes('<transcript>')) {
   // XML transcript format
   return this.parseXMLTranscript(content);
  } else if (content.includes('WEBVTT')) {
   // Standard VTT format
   return this.parseVTTContent(content);
  } else {
   // Try to extract timing information with regex
   return this.parseGenericTimedContent(content);
  }
 }

 /**
  * Utility functions
  */
 timeToSeconds(timeString) {
  const parts = timeString.replace(',', '.').split(':');
  const seconds = parts[2].split('.');
  return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(seconds[0]) + parseInt(seconds[1] || 0) / 1000;
 }

 cleanSubtitleText(text) {
  return text
   .replace(/<[^>]*>/g, '') // Remove HTML tags
   .replace(/&amp;/g, '&')
   .replace(/&lt;/g, '<')
   .replace(/&gt;/g, '>')
   .replace(/&quot;/g, '"')
   .replace(/&#39;/g, "'")
   .replace(/\s+/g, ' ')
   .trim();
 }

 extractLanguageFromFilename(filename) {
  const match = filename.match(/\.([a-z]{2}(-[A-Z]{2})?)\.vtt$/);
  return match ? match[1] : 'en';
 }

 calculateTotalDuration(segments) {
  if (!segments || segments.length === 0) return 0;
  const lastSegment = segments[segments.length - 1];
  return lastSegment.start + lastSegment.duration;
 }

 /**
  * Cleanup temporary files
  */
 async cleanupTempFiles(videoId) {
  try {
   const patterns = [path.join(this.tempDir, `${videoId}*`), path.join(this.tempDir, `*${videoId}*`)];

   for (const pattern of patterns) {
    const files = glob.sync(pattern);
    for (const file of files) {
     try {
      fs.unlinkSync(file);
      console.log(`[ADV-TRANSCRIPT] 🗑️  Cleaned up: ${file}`);
     } catch (error) {
      // Ignore cleanup errors
     }
    }
   }
  } catch (error) {
   console.log(`[ADV-TRANSCRIPT] ⚠️ Cleanup warning: ${error.message}`);
  }
 }
}

module.exports = AdvancedTranscriptExtractor;
